# Лабораторная работа №1: Разработка защищенного REST API с интеграцией в CI/CD

## Назначение
Получить практический опыт разработки безопасного backend-приложения с автоматизированной проверкой кода на уязвимости. Освоить принципы защиты от OWASP Top 10 и интеграцию инструментов безопасности в процесс разработки.

## Описание реализованных методов API

### Эндпоинты

| Метод | URL | Описание |
|-------|-----|----------|
| POST | `/auth/register` | Регистрация нового пользователя |
| POST | `/auth/login` | Аутентификация, получение JWT-токена | 
| GET | `/api/data` | Получение списка всех пользователей | 

**Примеры запросов:**
```bash
curl -X POST http://127.0.0.1:5000/auth/register \
  -H "Content-Type: application/json" \
  -d '{"username": "alice", "password": "secret"}'
```

```bash
curl -X POST http://127.0.0.1:5000/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username": "alice", "password": "secret"}'
```

```bash
curl -X GET http://127.0.0.1:5000/api/data \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
```

**Примеры ответов:**
```json
{"msg":"User created successfully"}
```

```json
{"access_token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."}
```

```json
{"users":[{"id":1,"username":"alice"}]}
```

---

## Внедрение базовых мер защиты

### Защита от SQL-инъекций (SQLi)

В проекте используется **SQLAlchemy ORM**, который автоматически параметризует запросы, исключая возможность SQL-инъекций:

```python
user = User.query.filter_by(username=username).first()
```

ORM преобразует код в параметризованный запрос, где значение `username` передаётся отдельно от структуры запроса, что делает инъекции невозможными.

### Защита от межсайтового скриптинга (XSS)

При формировании ответа `GET /api/data` все имена пользователей экранируются:

```python
safe_username = u.username.replace('<', '&lt;').replace('>', '&gt;')
```

Это преобразует потенциально опасные символы в HTML-сущности. Например, имя `<script>alert(1)</script>` превращается в `&lt;script&gt;alert(1)&lt;/script&gt;` и не будет выполняться браузером как код.

### Защита от нарушений аутентификации (Broken Authentication)

#### Хэширование паролей

Пароли хэшируются с использованием **bcrypt** (через библиотеку `Flask-Bcrypt`):

```python
password_hash = bcrypt.generate_password_hash(password).decode('utf-8')
```

Bcrypt автоматически генерирует соль и является медленным алгоритмом, что затрудняет перебор паролей.

#### JWT-токены

При успешной аутентификации создаётся JWT-токен с идентификатором пользователя:

```python
access_token = create_access_token(identity=str(user.id))
```

Токен подписывается секретным ключом и отправляется клиенту. Время жизни токена можно настроить самостоятельно.

#### Middleware проверки токена

На защищённых эндпоинтах используется декоратор `@jwt_required()`:

```python
@app.route('/api/data', methods=['GET'])
@jwt_required()
```

При отсутствии или недействительности токена возвращается ошибка `401 Unauthorized` или `422 Unprocessable Entity`.

---

## Инструменты анализа в CI/CD

### SAST: Bandit

Bandit анализирует исходный код Python и выявляет потенциальные уязвимости, такие как заданные в коде пароли, незащищённое открытие файлов, слабые методы шифрования. После выполнения workflow детальный отчёт Bandit сохраняется в `bandit_report.html`.

![Отчёт Bandit](bandit_res.png)

### SCA: Safety

Safety проверяет зависимости из `requirements.txt` на наличие известных уязвимостей. При обнаружении уязвимой библиотеки выводится предупреждение с указанием CVE и рекомендуемой версии.

### Автоматические тесты API

Тесты (`test_api.py`) проверяют все возможные результаты вызова эндпоиинтов из задания

---

## Ответы на контрольные вопросы

### 1. Почему хэширование пароля с помощью алгоритмов вроде bcrypt предпочтительнее использования SHA-256?

**Ответ:**


### 2. В чем заключается основная разница между SAST и DAST-подходом к тестированию безопасности?

**Ответ:**

### 3. Опишите механизм работы JWT-токена. Какая информация в нем содержится и как сервер проверяет его подлинность?

**Ответ:**


### 4. Какие риски возникают, если не проводить аудит сторонних библиотек (зависимостей) в проекте?

**Ответ:**

