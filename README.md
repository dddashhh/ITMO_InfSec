# Лабораторная работа №1: Разработка защищенного REST API с интеграцией в CI/CD

## Назначение
Получить практический опыт разработки безопасного backend-приложения с автоматизированной проверкой кода на уязвимости. Освоить принципы защиты от OWASP Top 10 и интеграцию инструментов безопасности в процесс разработки.

## Описание реализованных методов API

### Эндпоинты

| Метод | URL | Описание |
|-------|-----|----------|
| POST | `/auth/register` | Регистрация нового пользователя |
| POST | `/auth/login` | Аутентификация, получение JWT-токена | 
| GET | `/api/data` | Получение списка всех пользователей | 

**Примеры запросов:**
```bash
curl -X POST http://127.0.0.1:5000/auth/register \
  -H "Content-Type: application/json" \
  -d '{"username": "alice", "password": "secret"}'
```

```bash
curl -X POST http://127.0.0.1:5000/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username": "alice", "password": "secret"}'
```

```bash
curl -X GET http://127.0.0.1:5000/api/data \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
```

**Примеры ответов:**
```json
{"msg":"User created successfully"}
```

```json
{"access_token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."}
```

```json
{"users":[{"id":1,"username":"alice"}]}
```

---

## Внедрение базовых мер защиты

### Защита от SQL-инъекций (SQLi)

В проекте используется **SQLAlchemy ORM**, который автоматически параметризует запросы, исключая возможность SQL-инъекций:

```python
user = User.query.filter_by(username=username).first()
```

ORM преобразует код в параметризованный запрос, где значение `username` передаётся отдельно от структуры запроса, что делает инъекции невозможными.

### Защита от межсайтового скриптинга (XSS)

При формировании ответа `GET /api/data` все имена пользователей экранируются:

```python
safe_username = u.username.replace('<', '&lt;').replace('>', '&gt;')
```

Это преобразует потенциально опасные символы в HTML-сущности. Например, имя `<script>alert(1)</script>` превращается в `&lt;script&gt;alert(1)&lt;/script&gt;` и не будет выполняться браузером как код.

### Защита от нарушений аутентификации (Broken Authentication)

#### Хэширование паролей

Пароли хэшируются с использованием **bcrypt** (через библиотеку `Flask-Bcrypt`):

```python
password_hash = bcrypt.generate_password_hash(password).decode('utf-8')
```

Bcrypt автоматически генерирует соль и является медленным алгоритмом, что затрудняет перебор паролей.

#### JWT-токены

При успешной аутентификации создаётся JWT-токен с идентификатором пользователя:

```python
access_token = create_access_token(identity=str(user.id))
```

Токен подписывается секретным ключом и отправляется клиенту. Время жизни токена можно настроить самостоятельно.

#### Middleware проверки токена

На защищённых эндпоинтах используется декоратор `@jwt_required()`:

```python
@app.route('/api/data', methods=['GET'])
@jwt_required()
```

При отсутствии или недействительности токена возвращается ошибка `401 Unauthorized` или `422 Unprocessable Entity`.

---

## Инструменты анализа в CI/CD

### SAST: Bandit

Bandit анализирует исходный код Python и выявляет потенциальные уязвимости, такие как заданные в коде пароли, незащищённое открытие файлов, слабые методы шифрования. После выполнения workflow детальный отчёт Bandit сохраняется в `bandit_report.html`.

![Отчёт Bandit](bandit_res.png)

### SCA: Safety

Safety проверяет зависимости из `requirements.txt` на наличие известных уязвимостей. При обнаружении уязвимой библиотеки выводится предупреждение с указанием CVE и рекомендуемой версии.

### Автоматические тесты API

Тесты (`test_api.py`) проверяют все возможные результаты вызова эндпоиинтов из задания

---

## Ответы на контрольные вопросы

### 1. Почему хэширование пароля с помощью алгоритмов вроде bcrypt предпочтительнее использования SHA-256?

**Ответ:**

Основная проблема SHA-256 — высокая скорость. Можно вычислять миллионы хэшей в секунду, что делает перебор паролей практичным даже с солью.

Bcrypt специально разработаны для замедления перебора за счёт:

*   **Соли** (случайная строка данных, которая добавляется к паролю перед тем, как вычислить его хэш) — уникальна для каждого пароля, исключает радужные таблицы.
*   **Регулируемой вычислительной сложности** — время хэширования можно увеличивать пропорционально росту мощностей.

Математически время вычисления считается так:
*   для **bcrypt**: \( T = k * 2<sup>cost</sup> \), где cost — фактор стоимости (число итераций = 2<sup>cost</sup>);
*   для **PBKDF2**: \( T = k * c \), где \( c \) — количество итераций.

При достаточно большом cost или \( c \) время проверки одного пароля становится настолько большим, что полный перебор всех вариантов за разумное время невозможен. SHA-256 такой возможности не предоставляет. Поэтому использование адаптивных алгоритмов предпочтительный вариант.

### 2. В чем заключается основная разница между SAST и DAST-подходом к тестированию безопасности?

**Ответ:**

SAST (Static Application Security Testing) и DAST (Dynamic Application Security Testing) — это два подхода к тестированию безопасности приложений. Их основное различие лежит в объекте и времени анализа

| Характеристика | SAST | DAST |
| :--- | :--- | :--- |
| **Объект анализа** | Исходный код, байт-код или бинарные файлы приложения (анализ без выполнения программы). | Работающее приложение извне, без доступа к его внутреннему устройству. |
| **Когда применяется** | На ранних этапах разработки. | На поздних этапах - после развертывания в тестовой среде |
| **Тип выявляемых уязвимостей** | Ошибки в коде: внедрение кода (SQLi, XSS), недостатки шифрования, некорректная обработка ошибок, «дыры» в логике на уровне кода. | Ошибки конфигурации, проблемы аутентификации и сессий, уязвимости в рантайме, недостатки в логике работы приложения, видимые извне. |

SAST помогает предотвратить появление уязвимостей на ранних стадиях, а DAST проверяет, насколько безопасно приложение в итоговом образе. В идеале эти подходы должны использоваться вместе для обеспечения максимального покрытия безопасности на всех этапах жизненного цикла разработки

### 3. Опишите механизм работы JWT-токена. Какая информация в нем содержится и как сервер проверяет его подлинность?

**Ответ:**

**JWT (JSON Web Token)** — это компактный токен для безопасной передачи данных между сторонами в виде JSON. Информация в нем подтверждена цифровой подписью.

Токен состоит из трех частей, разделенных точками:  
`Header.Payload.Signature`

*   **Header** — метаданные: алгоритм подписи (например, `HS256`) и тип токена (`JWT`).
*   **Payload** — данные: идентификатор пользователя (`sub`), время выпуска (`iat`), срок действия (`exp`) и т.д.
*   **Signature** — подпись, созданная путем кодирования Header и Payload в Base64Url и их подписания секретом.

Алгоритм проверки подлинности
1.  Токен разделяется на три части.
2.  Заново вычисляется подпись, используя Header, Payload и секретный ключ.
3.  Сравниваем вычисленную подпись с полученной от клиента.
4.  Если подписи совпадают и срок действия (`exp`) не истек — токен считается подлинным.


### 4. Какие риски возникают, если не проводить аудит сторонних библиотек (зависимостей) в проекте?

**Ответ:**

Если не проводить регулярный аудит зависимостей, проект становится уязвимым сразу с нескольких сторон. Устаревшие или непроверенные библиотеки могут содержать известные CVE-уязвимости, которые злоумышленники активно эксплуатируют. Также существует риск атаки на цепочку поставок: вредоносный код может быть внедрён в стороннюю библиотеку. В-третьих, некоторые пакеты могут иметь лицензии, несовместимые с коммерческим использованием, что создаёт юридические риски для компании. Дополнительно увеличивает риски неконтролируемый рост транзитивных зависимостей, так как увеличивает поверхность атаки и усложняет поддержку проекта. 
